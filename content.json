{"pages":[],"posts":[{"title":"Array(数组)","text":"1.特点：a.数组一旦被定义，大小不可改变（java特性，长度一开始就定义好了） b.数组是引用数据类型，但是数组可以被定义成存储任意类型8个基本类型 c.数组中的数据类型必须是一致的，和定义的类型一致数组在创建时就一定要声明类型，然后数组就只能存储这个类 型 d.数组有默认值，默认是就是定义类型的默认值 byte short int ---0 long--0L float double ---0.0 char---\\u000 String----null e.数组有顺序，以下标定义 从0-length-1 2.声明a.动态赋值​ 通过下标赋值 1int [] arr; ​ //声明一个变量这个变量是数组类型的，名字都叫做arr 1arr = new int[3]; ​ //给开辟一个空间，大小为3，没有值，把这个空间赋值给变量arr 123int [] arr = new int[3];arr[0] = 12; ​ b.静态初始化 ​ c.默认初始化 3.操作​ a.冒泡排序：比较相邻的两个数 ​ b.增删改 ​ 增：先进行数组扩容 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(String[] args) {​ int [] arr1 = {1,2,3,4,5,6,7};​ add(arr1,3,10);​ }​ public static void add(int [] arr,int index,int a) {​ int [] arr2 = new int[arr.length+1];​ for(int i=0;i&lt;arr.length;i++) {​ arr2[i] = arr[i];​ ​ }​ arr = arr2;​ if(index&gt;=arr.length) {​ System.out.println(\"下标越界\");​ }​ else {​ for(int i=arr.length-1;i&gt;=index;i--) {​ arr[i] = arr[i-1];​ }​ arr[index] = a;​ System.out.println(Arrays.toString(arr));​ }​ } ​ c.查询 ​ forEach ​ 格式：for（数据类型 变量名：数组）{} 4.二维数组​ a.动态初始化 1int [][] arr = new int [][]; ​ b.静态赋值 1234567int[][] arr = {｛1，2，3｝，｛4，5，6｝｝","link":"/2020/02/19/Array/"},{"title":"Class(类)","text":"1.定义类的语法1234567891011121314151617181920212223242526272829303132333435363738394041public class 类名｛//a.属性//b.函数，方法｝//举例public class Dog {​ //属性----成员变量（有默认值）String color;String name;int age;String type;public static void eat(String food) {​ System.out.println(\"狗狗在吃：\"+food);}//加上static 和不加只是调用不同，暂时不加public void shout() {​ System.out.println(type+\"的狗在大叫\");}public void introduce() {​ System.out.println(\"这只泰迪\"+age+\"岁了\");}} 2.定义对象的语法类名 变量名 = new 类名（）；​ 访问属性：对象名.属性名； ​ 访问方法：对象名.方法名； 3.类和对象在内存中的分析4.构造方法​ 每一个类中都有一个默认的隐藏的构造方法（没有参数） ​ 但是当我们写了有参数的构造方法之后，无参数的构造方法就没了，需要手动添加. ​ 构造方法的作用： a.用来创建对象 new+构造方法（构造器）b.初始化成员变量例子： 1234567891011121314151617public Dog() {​ System.out.println(\"构造方法\");​ }​ //有参构造给成员变量赋值​ public Dog(String name,String color,int age) {​ this.name = name ;​ this.color = color;​ this.age = age ;​ }","link":"/2020/02/19/Class/"},{"title":"Extends(继承)","text":"extends —继承父类非私有的属性和方法 注意点：不能多继承，但是可以多层次继承 super—指的是父类本身 a.访问方法：访问当前父类中的方法，使用super.方法(); b.访问属性：访问当前父类中的属性，super.属性 c.访问构造方法：调用父类的构造方法，只能写在第一行，super(值) 重写：当父类的方法不满足子类的需求的时候需要重写，只改变方法体 ​ （此处区分重载和重写的区别） toString方法：//toString —在输出对象的时候自动调用，所有的类都有这个toString，toString的方法是object //object的toString是输出这个对象的地址，如果我们不想输出地址，就重写 //@Override //表示这个方法是重写 ​ 1234567@Overridepublic String toString() {//生成一个重写的toString --输出所有的属性​ return \"Workers [name=\" + name + \", sex=\" + sex + \", age=\" + age + \"]\";​ } equals方法：//object的方法，用于比较，原生方法为== //基本类型用==比较时，比较的是值；而引用类型比较的是地址； //重写equals用于判断两个属性是否相等 //jdk提供的类，几乎都是重写了equals，这些重写的equals都是比较的值","link":"/2020/02/19/Extends/"},{"title":"Encapsulation(封装)","text":"在Java总封装提供了四个权限修饰符：public：公共的—整个项目中所有的都可以访问（项目可见性） protected：受保护的—当前包以及其他包的子类 default：默认的–当前包（包可见性） private：私有的–当前类（类可见性） 为什么需要封装？a.方便访问 b.数据安全性 ​ public protected default private 类 * * 属性 * * * * 方法 * * * * //如果类是被public修饰的，那么构造方法也是被public修饰 //构造方法不是所有的都是被public修饰的，他根据类来决定 //使用私有封装属性是最常用的，因为以防数据不合理和数据不安全 //给私有属性提供setter和getter方法 格式 set+属性名（首字母大写） get+属性名（首字母大写） 1234567891011121314151617public class Cat{private int age ;public void setAge(int age){this.age = age ;}public void getAge(){return age ;}} this的作用 ：a.访问方法 1234567public void a(){}public void b(){this.a();//访问当前类中的其他方法} b.访问属性 当成员变量和局部变量同名时，用this.xx代表成员变量 c.访问构造方法 this.(值)—表示调用当前类中的构造方法（只能写在第一行）","link":"/2020/02/19/Encapsulation/"},{"title":"Abstract(抽象)","text":"1.使用abstract修饰的类，写出来就是为了被继承，（不可以使用final修饰） 1public abstract class Animals{} 2.不能创建对象（创建对象没有意义，是一个不完整的规范） 3.在抽象类中可以定义普通类中定义的所有（变量，常量，方法，构造方法） 4.抽象方法没有方法体，加上abstract 修饰方法 1public abstract void b（）{} 关键字final：修饰的变量是常量，只能赋值一次 ​ 如果修饰的是方法，则该方法不能被重写 如果修饰的是类，则该类不能被继承（不能和abstract共用） *final修饰的类有：String，Math ；属性有：PI*finalized：这是个垃圾回收的方法，一般不会手动调用，jvm（虚拟机）自动调用， 会在垃圾回收之前自动调用 finally：这个是异常处理中的 static：静态//static修饰属性和方法：static修饰的都是属于类的，整个类都只有一份，根据类创建的对象也只有这一份，如果没有static修饰的变量每次创建新对象都会各自有一份 //static修饰的是在第一次使用类的时候，进行加载，整个类中只加载1次 static修饰的方法不能被重写 //static修饰的是类，在第一次使用类的时候加载，第一次使用类的时候可能 还没有对象（Student a；）所以在static 修饰的方法中，不能直接调用非static的方法和属性 因为这个时候还没创建对象 new Student().方法名();如果想要调用 则需要创建一个对象也不能有this，this指的是对象 //非static修饰的是对象的，有对象的时候肯定已经使用了类，加载过static修饰 new Student(); 在非静态类中，可以调用静态的方法属性 两种访问方式： a.创建对象访问 b.类名.方法 / 类名.属性","link":"/2020/02/19/Abstract/"},{"title":"Interface(接口)","text":"1.定义 a.接口中只能定义常量和抽象方法，不能定义变量—-自动加上public static final b.可以定义static修饰的普通方法，不能定义非静态（非static）的普通方法 ​ 例如 static void c(){}(会自动加上public) 例如 public void c(){} c.可以定义抽象方法—–会自动加上public abstract 例如 void b(){} d.不能定义构造方法，不能创建对象 ​ 接口的子类和子口的关系叫做实现 implements ​ 子类实现接口的抽象方法，会具有接口的常量和抽象方法 ​ 但是子类不会继承父类（接口）的static修饰的普通方法 ​ 需要通过接口名.方法名（）访问 接口的多实现，接口和接口之间可以多继承","link":"/2020/02/20/Interface/"},{"title":"Polymorphism(多态)","text":"1.多态的语法：有继承和实现的时候（条件） 重写方法 父类的引用 //编译过程中不确定具体类型，等待运行后在确定具体类，根据运行是的类型来确定 2.多态就是引用数据类型的一种自动类型转换，向上转型（子类的对象指向父类的引用）例如： Animals am = new Dog(); a.多态的情况下，不能调用子类独有的方法（比如子类Dog独有的方法） b.多态的情况下，如果子类方法重写了父类的方法，则调用的是子类重写的方法 c.多态的情况下，调用的只能是父类的属性 3.多态的作用：a.作为返回值 b.作为参数 拓展：内部类：写在类中，或者方法中的类1.成员内部类： 把类当作成员，可以使用所有权限修饰符 可以定义一个比private更小的范围，可以实现一个外部 类继承1个内部类和继承1个类 但是不能定义静态属性和方法 123456789101112131415161718192021public class a{public void b(){​ // c() ; //错误调用​ new InnerClass().c(); //正确方法}private class InnerClass{//属于对象​ b（）；​ public void c(){​ }}} 2.静态内部类 ：可以定义静态属性 3.方法内部类： 也叫匿名内部类 1234public interface B { void eat(String food); } 12345678910// 语法一// B b = new B() {// // @Override// public void eat(String food) {// // TODO Auto-generated method stub// System.out.println(\"吃\"+food);// }// };// b.eat(\"肉\"); 12345//语法二B b2 = (String food)-&gt;{ System.out.println(\"吃\"+food);};b2.eat(\"菜\");","link":"/2020/02/20/Polymorphism/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"java学习笔记","slug":"java学习笔记","link":"/categories/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}